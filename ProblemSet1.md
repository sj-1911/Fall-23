Code Here --> https://colab.research.google.com/drive/1xAqpcvhO0JFSz1aNn0eiSdqzkAA6TXF8?usp=sharing

# -*- coding: utf-8 -*-
"""Problem1_SJ.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xAqpcvhO0JFSz1aNn0eiSdqzkAA6TXF8

# Load MNIST and run Montage
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# import numpy as np
# import matplotlib.pyplot as plt
# import torch
# from torchvision import datasets
# from skimage.util import montage
# !pip install wandb
# import wandb as wb
# from skimage.io import imread

# Define GPU tensor functions

def GPU(data):
    """
    Converts input data to a GPU tensor with gradient tracking.

    Args:
    data: Input data

    Returns:
    GPU tensor
    """
    return torch.tensor(data, requires_grad=True, dtype=torch.float, device=torch.device('cuda'))

def GPU_data(data):
    """
    Converts input data to a GPU tensor without gradient tracking.

    Args:
    data: Input data

    Returns:
    GPU tensor
    """
    return torch.tensor(data, requires_grad=False, dtype=torch.float, device=torch.device('cuda'))

# Define plot functions

def plot(x):
    """
    Plot a given image or tensor.

    Args:
    x: Input image or tensor

    Returns:
    None
    """
    if type(x) == torch.Tensor :
        x = x.cpu().detach().numpy()

    fig, ax = plt.subplots()
    im = ax.imshow(x, cmap = 'gray')
    ax.axis('off')
    fig.set_size_inches(7, 7)
    plt.show()

def montage_plot(x):
    """
    Create and display a montage of images.

    Args:
    x: Input array of images

    Returns:
    None
    """
    x = np.pad(x, pad_width=((0, 0), (1, 1), (1, 1)), mode='constant', constant_values=0)
    plot(montage(x))

# Load MNIST dataset
train_set = datasets.MNIST('./data', train=True, download=True)
test_set = datasets.MNIST('./data', train=False, download=True)

# Preprocess MNIST dataset
X = train_set.data.numpy()
X_test = test_set.data.numpy()
Y = train_set.targets.numpy()
Y_test = test_set.targets.numpy()

X = X[:, None, :, :] / 255
X_test = X_test[:, None, :, :] / 255

# Display the shape of X
X.shape

# Visualize an example image
x = X[3, 0, :, :]
plt.imshow(x)
plot(x)

# Reshape the image
x = x.reshape(x.shape[0] * x.shape[1], 1)
x.shape

# Reshape the image back to (28, 28) and plot it
x = x.reshape(28, 28)
plot(x)

# Plot another image from X
plot(X[100, 0, :, :])

# Display the label for a specific image
Y[120]

# Select a subset of images from X and visualize them as a montage
montage_plot(X[125:150, 0, :, :])

"""# Run random y=mx+b model on MNIST"""

# Reshape X for modeling
X = X.reshape(X.shape[0], 784)
X_test = X_test.reshape(X_test.shape[0], 784)

# Transpose X and Y
X = X.T
X = GPU_data(X)
Y = GPU_data(Y)
X_test = GPU_data(X_test)
Y_test = GPU_data(Y_test)

# Display the shape of X after transposing
X.shape

# Select a subset of data for modeling
x = X[:, 0:64]
Y[0:64]

# Plot an image from the subset
plot(x[:, 62].reshape(28, 28))

# Initialize a random model parameter matrix M
M = GPU(np.random.rand(10, 784))

# Display the shapes of M and x
M.shape, x.shape

# Perform matrix multiplication M@x
y = M @ x
y.shape

# Find the maximum value in each column of y
torch.max(y, 0)

# Find the index of the maximum value in each column of y
y = torch.argmax(y, 0)
y

# Display the labels for the subset of data
Y[0:64]

# Check if predicted labels match true labels
y == Y[0:64]

# Calculate the accuracy of the predictions
torch.sum((y == Y[0:64])) / 64

# Define batch size
batch_size = 64

# Initialize a random model parameter matrix M
M = GPU(np.random.rand(10, 784))

# Perform matrix multiplication M@x
y = M @ x

# Find the index of the maximum value in each column of y
y = torch.argmax(y, 0)

# Calculate the accuracy of the predictions for the batch
torch.sum((y == Y[0:batch_size])) / batch_size

# Reshape a random array z
z = np.random.rand(10, 784)
z.shape

# Get the dimensions of z
z.shape[0], z.shape[1]

# Flatten the array z
count = z.shape[0] * z.shape[1]
z = z.reshape(count, )
z.shape

# Reshape a random array z
z = np.random.rand(10, 784)
z.shape

# Flatten the array z using the flatten() method
z = z.flatten()
z.shape

# Reshape a random array z with different dimensions
z = np.random.rand(1000, 78)

# Reshape the array using the -1 argument to infer one dimension
z = z.reshape(-1)
z.shape
